\newpage
\section{Implementation}

This part will explain our implementation of VEM for the resolution of Laplace problem with Dirichlet boundary conditions in $2$D and $2$D, on respectively polygonal or polyhedral meshes. C++ has been used, making the most of the fact that it is an object oriented programming language. Moreover, a Makefile has been written to automate compilation, and a Doxygen full documentation of the implementation can also be automatically generated. To visualize the results, we have however preferred to create some Python scripts, taking advantage of Mayavi library for $3$D plots. We have tried to adopt a coding style as coherent and easily readable as possible, to make the comprehension easier. 

\subsection{Global view on the code}
The code is based on $18$ classes and a main file. Making the most of \textit{template programming} techniques, declaration and implementation of each class are both in a header file. Memory layout has been done with the most recent C++ techniques in order to avoid memory leaks. In particular, where pointers are necessary, they have been implemented as smart (shared or weak) pointers. While writing the code, our aim has always been to create a code as general and reusable as possible. The code is essentially and ideally divided into two main parts:
\begin{itemize}
\item \textbf{The mesh:} $7$ classes serve to its implementation, where any $2$D or $3$D mesh composed by non-necessarily convex elements are modelled. The flexibility brought by VEM with respect to the geometry makes this part quite complex and computationally not negligible. Computing some properties of the polygons/polyhedrons (as the elements volume, external normal, etc.) is significantly more complex than for standard grids or triangular meshes, but it is essential for the problem resolution. 
\item \textbf{Problem solving using VEM:} in this part, we have first tried to create a code that solves Laplace problem on any mesh regardless of the type of solver and of the imposed boundary conditions. Based from this first working part, we have implemented the Virtual Element Method solver and Dirichlet boundary conditions, the only solver and boundary conditions considered in this project. The idea has been to implement a code that is as general as possible, so that we could modify the method (for example to use the Finite Element Mehod instead of VEM) by only writing a new class corresponding to a new solver, without touching the part corresponding to the problem or the boundary conditions. In the same way, we could easily add some classes to consider other equations or other boundary conditions. 
\end{itemize}

Apart from those two main parts, there is a \textit{main} file where the appropriate solver can be run. The parameters needed to solve the problem (type of geometry, type of mesh, force term, name of the output file, etc.) are specified in a \textit{datafile} so that we do not need to recompile the whole code for any small modification. 

As already said, we have also added a separate part written in Python in order to have a graphical visualization of the results. Python has been chosen thanks to its simplicity compared to C++ for the implementation of graphical interfaces, and thanks to the presence of the library \textit{Mayavi}, well adapted to $3$D visualization. This has been implemented to be complementary to the rest of the code, in order to furnish a fast way to graphically verify  the solutions. 

\subsection{Mesh}
We have chosen to write from scratch the code to create a mesh because of the particularity of VEM to handle more general elements compared to the classical Finite Element Method. 

A mesh in $3$D has been thought as an ensemble of polyhedrons. Each polyhedron is composed of a set of polygons that are themselves defined as an ordered set of points. The class \verb|Mesh| is based on the $3$ classes that represent polyhedrons, polygons and points. Those three classes are tightly interconnected: each polyhedron contains a vector of pointers to the points corresponding to its vertices, and an other vector of pointers to the polygons corresponding to its faces. This makes the constructor of such objects more difficult to write, but the difficulties have been surmounted thanks to the \textit{variadic template} techniques and to a method fully dedicated to the creation of instances. In this situation, we have also chosen to use \textit{shared pointers} when pointers are needed to make the memory management easier to handle. It has been decided not to use \textit{unique pointers} since inside the program, the same pointer can be used by different instances of different classes. 

A mesh in $2$D has been implemented in a similar way, but avoiding the presence of polyhedrons. However, a class Edge has not been necessary, thus it has not been implemented in order to keep a structure as simple as possible. 

Two template parameters, \textit{embedded} and \textit{real} are present in every class. They guarantee some flexibility with respect to the chosen space ($2$D or $3$D) and to the precision of the data (double or long double types can be used). 

\subsubsection{Point and MeshPoint} \label{pts}
The classes \verb|Point| and \verb|MeshPoint| both represent a point in the $2$D or $3$D space. However, as their names suggest, \verb|Point| represents a generic point while \verb|MeshPoint| represent a point belonging to a mesh. In each instance of \verb|MeshPoint| is also stored the polygons and polyhedrons that have this point as vertex. No copy constructor is implemented in \verb|MeshPoint|, copying any such instance is forbidden. \verb|MeshPoint| also keeps into memory the ID of the point corresponding to the given mesh, and the information about whether a point is on the boundary of the considered geometry or not. 

Class \verb|Point| is also used to represent a (geometrical) vector. Indeed, a point is only represented by an array of numbers corresponding to its coordinates. This is also sufficient to represent a vector. This is why class Point also contains methods to compute the norm of a vector or a cross product. 

The presence or the absence of the copy constructor is however the main difference between both classes: in class Point, it is very useful to compute faster everything we need; but in \verb|MeshPoint| it would even be harmful. Indeed, it would be difficult to keep the tight interconnection between classes used to create meshes if one of their component (as a vertex) were copied. \\

Here is reported the implementation of class \verb|Point| and its main methods: \\

\textbf{TODO: CHANGE THE DISPLAY OF CODE...?}

\noindent\rule{12.7cm}{1pt}
\begin{verbatim}
template <long embedded,typename real=double>
class Point {

protected:
  array<real,embedded> coordinates;

public:
  // CONSTRUCTORS
  Point(const array<real,embedded>& inputArray);
  Point(const Point<embedded,real>& inputPoint);
  Point(const MeshPoint<embedded,real>& inputPoint);

  // Constructor with variadic template
  template <typename... Args>
  Point(Args... arguments);

  // STANDARD METHODS
  long maxIndex() const;	//!< Maximum index of the point
  long maxAbsIndex() const;	//!< Maximum index of the point 
with absolute value
  real norm() const;  //!< L2 norm of the vector
  real normL1() const; //!< L1 norm of the vector

  real& operator[](long index);	//!< Get an element by 
reference

  template <long embedded2,typename real2>
  friend Point<embedded2,real2> cross(const Point<embedded2,
real2>& point1, const Point<embedded2,real2>& point2);
};
\end{verbatim}

\noindent\rule{12.7cm}{1pt}\\

Here is reported the implementation of class \verb|MeshPoint| and its main methods:\\

\noindent\rule{12.7cm}{1pt}
\begin{verbatim}
template <long embedded,typename real=double>
class MeshPoint: public Point<embedded,real> {
protected:
  // PROPERTIES
  long pointID;	//!< ID of the MeshPoint
  real value;		//!< Value in the point after the resolution of 
the problem
  bool isBoundary;	//<! Tells if the MeshPoint is on the 
boundary

  vector<weak_ptr<Polygon<embedded, real>>> polygonVector;
  vector<weak_ptr<Polyhedron<embedded,real>>> polyhedronVector;

  // CONSTRUCTORS
  // Constructor with variadic template
  template <typename... Args>
  MeshPoint(Args... arguments);

  // STANDARD METHODS
  void addPolygon(weak_ptr<Polygon<embedded,real>> 
inputPolygon); //!< It inserts in polygon vector a new Polygon
  void addPolyhedron(weak_ptr<Polyhedron<embedded,real>> 
inputPolyhedron); //!< It insert in polyhedron vector a new 
Polyhedron
\end{verbatim}

\noindent\rule{12.7cm}{1pt}\\

\subsubsection{Polygon and Polyhedron}
The two classes \verb|Polygon| and \verb|Polyhedron| represent a generic polygon or polyhedron, not necessarily convex. Both classes are to be understood as mesh components; but we have not implemented two different classes of both as for Point since it has not been necessary. The absence of copy constructor is then required as for \verb|MeshPoint|, for the same reasons (see paragraph \ref{pts}). For both classes \verb|Polygon| and \verb|Polyhedron|, the only way to create a new instance is by using methods \verb|make_shared_Polygon| or \verb|make_shared_Polyhedron|, that return a shared pointer to the new instance and that take care of handling connexions between them (since they are components of a given mesh). 
The use of \textit{variadic template} techniques guarantee some flexibility and readability of the code. For example, a \verb|Polygon| can be initialized either from an \verb|std::vector| of \verb|MeshPoint|s, or from an arbitrary number of \verb|MeshPoint|s. 

\verb|Polygon| is modelled as an ordered set of \verb|Point|s, in $2$D or $3$D. The order is necessary in order to be able to determine the sense of a normal vector, and in order to know if a polygon is convex or not (see paragraph \ref{polygons}). During the instantiation, the area, the normal vector and the barycentre of the polygon are computed. \verb|Polyhedron| instead, is a non ordered set of \verb|Polygon|s (see paragraph \ref{polyhedron}). During the instantiation are computed the volume, the external normal and the barycentre, and the normal vectors of the faces are coherently oriented (see paragraph \ref{polyhedron} for the algorithms used). \\

Here is reported the implementation of class \verb|Polygon| and its main methods:\\

\noindent\rule{12.7cm}{1pt}
\begin{verbatim}
template <long embedded, typename real=double>
class Polygon: public std::enable_shared_from_this<Polygon<
embedded,real>> {
protected:
  // PROPERTIES
  // Vector of ordered vertexes
  vector<shared_ptr<MeshPoint<embedded,real>>> pointVector;
	
  bool isBoundary;	// Tells if the Polygon is on the boundary
  real area;	// \return the area of the Polygon
  Vector<3, real> normal;	// oriented normal to the Polygon
  Point<embedded, real> centroid;	// centroid of the Polygon
  vector<weak_ptr<Polyhedron<embedded,real>>> polyhedronVector;

public:
  // CONSTRUCTORS
  Polygon(const privateStruct &, const vector<shared_ptr<
MeshPoint<embedded,real>>>& vertexVector);
  // Constructor with variadic template.
  template <typename... Args>
  Polygon(const privateStruct&,Args... arguments);

  template <typename... Args>
  static shared_ptr<Polygon<embedded,real>> make_shared_Polygon
(Args... arguments);

public:
  // STANDARD METHODS
  // Add a new vertex to the Polygon
  void addPoint(const shared_ptr<MeshPoint<embedded,real>>& p1); 
  // Add a new Polyhedron having this as face
  void addPolyhedron(weak_ptr<Polyhedron<embedded,real>> 
polyhedron);	
			
  Vector<embedded,real> computeCentroid();
  real computeArea();
  real getDiameter();
  real hTriangle(); // Compute the maximum distance 
between 2 vertexes.

  shared_ptr<MeshPoint<embedded,real>> isPointAVertex(Point
<embedded,real>& point);	
  bool isPointInside(Point<embedded,real>& point);
  array<shared_ptr<MeshPoint<embedded,real>>,2> 
isPointOnBoundary(Point<embedded,real>& point);

  Vector<3,real> computeNormal();
  void switchPointsOrder(); // Invert the orientation of the 
Polygon
\end{verbatim}

\noindent\rule{12.7cm}{1pt}\\

Here is reported the implementation of class \verb|Polyhedron| and its main methods:

\noindent\rule{12.7cm}{1pt}
\begin{verbatim}
template <long embedded, typename real=double>
class Polyhedron: public enable_shared_from_this<Polyhedron
<embedded,real>> {

protected:
  // PROPERTIES
  // Stores the faces of the Polyhedron
  vector<shared_ptr<Polygon<embedded,real>>> polygonVector; 
	
  bool isBoundary;	// Tells if the Polygon is on the boundary
  real volume;	// volume of the Polyhedron
  Point<embedded,real> centroid;	// Not the real centroid, 
only the mean of the vertexes.

  // Stores the vertexes of the Polyhedron
  vector<shared_ptr<MeshPoint<embedded,real>>> pointVector;	

public:
  // CONSTRUCTORS
  Polyhedron(const privateStruct&,const vector<shared_ptr
<Polygon<embedded,real>>>& inputPolygonVector);
  // Constructor with variadic template. DO NOT USE.
  template <typename... Args>
  Polyhedron(const privateStruct&,Args... arguments)

  template <typename ...Args>
  static shared_ptr<Polyhedron<embedded, real>>
make_shared_Polyhedron;

  // STANDARD METHODS
  // Add a new vertex to the Polygon
  void addPolygon(shared_ptr<Polygon<embedded,real>>& 
inputPolygon);
  // Add a new Polyhedron having this as face
  void addPoint(shared_ptr<MeshPoint<embedded,real>>& 
inputPoint);
  Point<embedded,real> computeCentroid();	// return the centroid
  real computeVolume();	// return the volume of the Polyhedron
  real getDiameter();		// return the maximum distance between 2 
Points
  // Makes the normal to each face pointing towards the external
of the Polyhedron
  void fixExternalNormal();	
  // Makes the normal of each face pointing in the same 
direction (or inward or outward)
  void fixFacesOrientation();	
  // Maximum distance between vertexes. Necessary for the mesh.
  real hTriangle();	
  void linkPoints();	// Makes all vertexes pointing to this
  void linkPolygons();  // Makes all Polygons pointing to this

  void switchFacesOrientation();	// Invert the orientation of
all faces
  // If a new face is added, also his vertexes are added to the
pointVector
  void updatePointVector();
\end{verbatim}
\noindent\rule{12.7cm}{1pt}\\

\subsubsection{Mesh, Mesh2D, Mesh3D}
\verb|Mesh| is an abstract class that represents a very general mesh (a solid in a $3$D space, a surface in a $2$D or in a $3$D space, etc.). In each instance of this class are memorized two vectors: one vector of \verb|Point|s and one of \verb|Polygon|s or \verb|Polyhedron|s depending on the chosen space. Basic methods are declared to read different types of files and build the mesh from them; they will suitably be implemented on the derived classes. Two other dedicated virtual methods are also declared in this class to keep track of the boundary elements and to eventually set other mesh properties. A constructor has also been defined and will be automatically called from the constructors of the derived classes. 

\verb|Mesh2D| is a derived class of \verb|Mesh|, used to model $2$D meshes in a $2$D space. For the lifting of the boundary elements, we look for edges present only in a unique polygon of the mesh. To optimize the computational time of research of boundary elements, we have introduced a vector of point tuples called \verb|pairVector|. This allows us to avoid the introduction of a class representing the edges, that would just have made the code uselessly more complex. Once created the mesh, \verb|pairVector| is analysed to find non duplicated edges. 

\verb|Mesh3D| is similar to \verb|Mesh2D| but to model $3$D meshes in a $3$D space. Because of the higher complexity of the mesh, it has been decided to also save the pointers to the faces of the polygon into a vector. This has allowed us to obtain the boundary elements with a similar algorithm to the $2$D case, but comparing the faces instead of the edges. In this case, and to make it faster, the algorithm to compare the faces is directly called at the instantiation of every new face. \\

Here is reported the implementation of class \verb|Mesh| and its main methods:

\noindent\rule{12.7cm}{1pt}
\begin{verbatim}
template <long embedded,typename baseElement,OpenEnum isOpen=
OPEN, typename real=double>
class Mesh {
protected:
    
    // Vector of Polygon or Polyhedron
    vector<shared_ptr<baseElement>> elementVector;	
    // Vector of the vertexes of each element
    vector<shared_ptr<MeshPoint<embedded,real>>> pointVector;	
	
public:
    long numberOfElements;
    long numberOfPoints;

    virtual real hTriangle();	// paramether h of the Mesh
	
    // Method that calls the functions that read the file
    void initialize(string pointFile,string connection,
MeshType meshType=ANYTHING3D);

    // It obtains the pointVector from file
    virtual void setPointVector(string file);	
    // It obtains the elementVector from connections
    virtual void setElementVector(string connections, MeshType
meshType);
    
    // Virtual method to keep into account the boundary 
elements
    virtual void setBoundaryElements()=0;
    //	Virtual method used to set other things, like pointIDs
    virtual void setRemainingThings()=0;

    // methods to set the elementVector
    virtual void setTetrahedronMesh(string connection); 
    virtual void setTriangleMesh(string connection);	
    virtual void setAnything3DMesh(string connection);
    virtual void setAnything2DMesh(string connection);
    virtual void setFileType1Mesh(string connection);
    virtual void setFileType2Mesh(string connection);

    virtual void sort(); //!< Sort the pointVector based on 
pointID
\end{verbatim}

\noindent\rule{12.7cm}{1pt}\\

Here is reported the implementation of class \verb|Mesh2D| and its main methods:

\noindent\rule{12.7cm}{1pt}
\begin{verbatim}
template <typename real=double>
class Mesh2D: public Mesh<2,Polygon<2,real>,OPEN,real> {
private:
    // This is to obtain internal and external points	
    vector<pair<long,long>> pairVector;

public:
    long numberOfBoundaryPoints;
	
    // Constructor with input file
    Mesh2D(string pointFile,string connectionFile,MeshType 
meshType=ANYTHING2D);

    template <typename... Args >
    shared_ptr<Polygon<2,real>> newPolygon(Args... arguments);

    // Mesh of ANYTHING2D type
    virtual void setAnything2DMesh(string connection);

    virtual void setBoundaryElements();
    virtual void setRemainingThings();
\end{verbatim}
\noindent\rule{12.7cm}{1pt}\\

Here is reported the implementation of class \verb|Mesh3D| and its main methods:

\noindent\rule{12.7cm}{1pt}
\begin{verbatim}
template <typename real=double>
class Mesh3D : public Mesh<3, Polyhedron<3,real>, OPEN, real> {
protected:
    // Vector of all the Polyhedron faces
    vector<shared_ptr<Polygon<3,real>>> polygonVector;  

public:
    long numberOfPolygons;
    long numberOfBoundaryPoints;

    // Constructor with input file
    Mesh3D(string pointFile,string connectionFile,MeshType 
meshType=ANYTHING3D);
	
    // STANDARD METHODS
    // Method to create a Polygon after having read it.
    template <typename... Args >
    shared_ptr<Polygon<3,real>> newFace(Args... arguments);

    virtual void setBoundaryElements();
    virtual void setRemainingThings();

    // Mesh of TETRAHEDRON type
    virtual void setTetrahedronMesh(string connection);
    // Mesh of ANYTHING3D type
    virtual void setAnything3DMesh(string connection);
\end{verbatim}
\noindent\rule{12.7cm}{1pt}\\

\subsection{Laplace equation and VEM solver}
For the part of the code that solves a numerical problem, we have tried to write a code as modular as possible, to be able to change solver easily or to consider different boundary conditions (even if in this project, only VEM and Dirichlet boundary conditions have been implemented). We have deeply use \textit{template programming} techniques to guarantee this modularity. Indeed, classes that model the numerical problem are all template classes, for which two parameters are needed: one for the type of solver and one for boundary conditions. A last class has been implemented to compute the error. To manage matrices, vectors and linear systems, the open-source Eigen has been used. 

\subsubsection{Problem and Laplace classes}
The abstract class \verb|Problem| models a very generic numerical problem, that can be solve through a linear system made of a stiffness matrix and of a constant term. The aim of class \verb|Problem| is to define an common interface for all types of problems, containing the definition of all the necessary methods and the implementation of the most generic ones. In particular, the creating of the stiffness matrix and of the constant term are left to the derived classes while a default linear system solver is implemented in the parent class (BiCGSTAB) that can be overwritten. 


