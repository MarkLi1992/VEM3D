\hypertarget{class_solver_v_e_m}{}\section{Solver\+V\+EM$<$ embedded, element\+Dimension, base\+Element, Monomial\+Type, real $>$ Class Template Reference}
\label{class_solver_v_e_m}\index{Solver\+V\+E\+M$<$ embedded, element\+Dimension, base\+Element, Monomial\+Type, real $>$@{Solver\+V\+E\+M$<$ embedded, element\+Dimension, base\+Element, Monomial\+Type, real $>$}}


Virtual basic class to solve\+V\+EM.  




{\ttfamily \#include $<$Solver\+V\+E\+M.\+h$>$}

Inheritance diagram for Solver\+V\+EM$<$ embedded, element\+Dimension, base\+Element, Monomial\+Type, real $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_solver_v_e_m}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_solver_v_e_m_ae0eca27b7af4c0877c0abe2cfbcfdcae}{Solver\+V\+EM} (std\+::function$<$ real(const \hyperlink{class_point}{Point}$<$ embedded, real $>$ \&)$>$ input\+Force\+Term)
\begin{DoxyCompactList}\small\item\em Basic constructor. \end{DoxyCompactList}\item 
virtual Matrix$<$ real, Dynamic, Dynamic $>$ \hyperlink{class_solver_v_e_m_acdbd3c97184fbd831b2f21e28148c33e}{compute\+LocalK} (const shared\+\_\+ptr$<$ base\+Element $>$ \&element)\hypertarget{class_solver_v_e_m_acdbd3c97184fbd831b2f21e28148c33e}{}\label{class_solver_v_e_m_acdbd3c97184fbd831b2f21e28148c33e}

\begin{DoxyCompactList}\small\item\em This is to compute the local stiffness matrix. \end{DoxyCompactList}\item 
virtual real \hyperlink{class_solver_v_e_m_af5b39e79f497fb28f63592c44120d5fe}{compute\+Known\+Term} (const shared\+\_\+ptr$<$ base\+Element $>$ \&element, const shared\+\_\+ptr$<$ \hyperlink{class_mesh_point}{Mesh\+Point}$<$ embedded, real $>$$>$ \&point)=0\hypertarget{class_solver_v_e_m_af5b39e79f497fb28f63592c44120d5fe}{}\label{class_solver_v_e_m_af5b39e79f497fb28f63592c44120d5fe}

\begin{DoxyCompactList}\small\item\em Virtual method to compute the known term. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual Matrix$<$ real, element\+Dimension+1, element\+Dimension+1 $>$ {\bfseries computeG} (Monomial\+Type \&monomial)\hypertarget{class_solver_v_e_m_a65980d6c3c850f5e8d037a9761438e93}{}\label{class_solver_v_e_m_a65980d6c3c850f5e8d037a9761438e93}

\item 
virtual Matrix$<$ real, element\+Dimension+1, Dynamic $>$ {\bfseries computeB} (const shared\+\_\+ptr$<$ base\+Element $>$ \&polyhedron, Monomial\+Type \&monomial)=0\hypertarget{class_solver_v_e_m_a512de296031ac2f954f95c2e78da063d}{}\label{class_solver_v_e_m_a512de296031ac2f954f95c2e78da063d}

\item 
virtual Matrix$<$ real, Dynamic, element\+Dimension+1 $>$ {\bfseries computeD} (Monomial\+Type \&monomial)\hypertarget{class_solver_v_e_m_a73bb74a85b8b436e8e24ed874c8c2ef9}{}\label{class_solver_v_e_m_a73bb74a85b8b436e8e24ed874c8c2ef9}

\item 
virtual Matrix$<$ real, element\+Dimension+1, Dynamic $>$ {\bfseries compute\+P\+I\+Star} (Matrix$<$ real, element\+Dimension+1, element\+Dimension+1 $>$ \&G, Matrix$<$ real, element\+Dimension+1, Dynamic $>$ \&B)\hypertarget{class_solver_v_e_m_a9f092078e8698d00c862e53cae1e20e1}{}\label{class_solver_v_e_m_a9f092078e8698d00c862e53cae1e20e1}

\item 
virtual Matrix$<$ real, Dynamic, Dynamic $>$ {\bfseries compute\+PI} (Matrix$<$ real, element\+Dimension+1, Dynamic $>$ \&P\+I\+Star, Matrix$<$ real, Dynamic, element\+Dimension+1 $>$ \&D)\hypertarget{class_solver_v_e_m_a8d296a88bc9f863fe72688cad49ef2a3}{}\label{class_solver_v_e_m_a8d296a88bc9f863fe72688cad49ef2a3}

\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\subsubsection*{template$<$long embedded, long element\+Dimension, typename base\+Element, typename Monomial\+Type, typename real = double$>$\\*
class Solver\+V\+E\+M$<$ embedded, element\+Dimension, base\+Element, Monomial\+Type, real $>$}

Virtual basic class to solve\+V\+EM. 

The idea is to implement here all the methods common to 2D and 3D cases and then to specilize the remainings

The methods are mainly methods to compute the characteristics matrixes.


\begin{DoxyParams}{Parameters}
{\em embedded} & Dimension of the space \\
\hline
{\em element\+Dimension} & dimension of each element (2 or 3) \\
\hline
{\em base\+Element} & \hyperlink{class_polygon}{Polygon} or \hyperlink{class_polyhedron}{Polyhedron} \\
\hline
{\em Monomial\+Type} & \hyperlink{class_monomials}{Monomials} or Monomial\+Polygon. The last can be used in case of V\+EM on surfaces \\
\hline
{\em real} & double or long double \\
\hline
\end{DoxyParams}


\subsection{Constructor \& Destructor Documentation}
\index{Solver\+V\+EM@{Solver\+V\+EM}!Solver\+V\+EM@{Solver\+V\+EM}}
\index{Solver\+V\+EM@{Solver\+V\+EM}!Solver\+V\+EM@{Solver\+V\+EM}}
\subsubsection[{\texorpdfstring{Solver\+V\+E\+M(std\+::function$<$ real(const Point$<$ embedded, real $>$ \&)$>$ input\+Force\+Term)}{SolverVEM(std::function< real(const Point< embedded, real > &)> inputForceTerm)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$long embedded, long element\+Dimension, typename base\+Element, typename Monomial\+Type, typename real = double$>$ {\bf Solver\+V\+EM}$<$ embedded, element\+Dimension, base\+Element, Monomial\+Type, real $>$\+::{\bf Solver\+V\+EM} (
\begin{DoxyParamCaption}
\item[{std\+::function$<$ real(const {\bf Point}$<$ embedded, real $>$ \&)$>$}]{input\+Force\+Term}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_solver_v_e_m_ae0eca27b7af4c0877c0abe2cfbcfdcae}{}\label{class_solver_v_e_m_ae0eca27b7af4c0877c0abe2cfbcfdcae}


Basic constructor. 

A lot of paramethers are given as template.


\begin{DoxyParams}{Parameters}
{\em input\+Force\+Term} & std\+::function as force term \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Solver\+V\+E\+M.\+h\end{DoxyCompactItemize}
